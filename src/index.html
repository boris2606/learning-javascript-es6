<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>JavaScript ES6+</title>
        <!-- <link rel="icon" type="image/x-icon" href="/images/favicon.ico"> тут іконка вкладки -->
    </head>
    <body>
        <div class="accordion accordion-flush" id="accordionFlushExample">
            <h1 class="tit_text_learn">JavaScript ES6 - Для ознайомлення оберіть розділ</h1>
            <!-- Змінні let та const -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingOne">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
                        <p class="header_name_item_stl">Змінні let | const</p>
                    </button>
                </h2>
                <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Змінні</p>
                        <p>Всі змінні бажано вказувати в стилі "camelCase"<code>(приклад: let firstName = 'Ivan')</code></p>
                        <ul>
                            <li class="list_style_accord"><code>const = 42</code>  Змінні такого типу присутні лише для читання, перезапис даної змінної недоступний (бажано використовувати якщо змінна являється незмінною). Але якщо це масив, чи об'єкт, присутня змога робити в ньому зміни, але без перепризнаення.</li>
                            <li class="list_style_accord"><code>let = 42</code> Оголошення змінної, доступна для перезапису. До них можна звернутись лише в межах одних фігурних скобок </li>
                        </ul>
                    </article>
                </div>
            </div>
            <!-- Стрілочні функції -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTwo">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
                        <p class="header_name_item_stl">Стрілочні функції</p>
                    </button>
                </h2>
                <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Приклад стрілочної функції:</p>
                        <ul>
                            <li class="list_style_accord">
                                <code>
                                    function person(name){ <code class="comment_code">// Приклад звичайної функції</code><br>console.log('Привіт - ', name)<br>}<br>
                                </code>
                            </li>
                            <li class="list_style_accord">
                                <code>
                                    let arrow = (name) => { <code class="comment_code">// Приклад стрілочної функції, де name параметр</code><br>console.log('Привіт - ',name)<br>}<br>
                                </code>
                            </li>
                            <li class="list_style_accord">
                                <code>
                                    let arrow = name => console.log('Привіт - ',name)<br>
                                </code>
                                <code class="comment_code">// Скорочений приклад стрілочної функції, де name параметр, його можна не брати в дужки так як параметр тільки 1, також у фігурні дужки не берем умову, у зв'язку з тим що умова у вигляді однієї стрічки</code>
                            </li>
                        </ul>
                        <p>Усі ці функції рівнозначні, мають лише різний запис. Якщо до функції не передаються параметри, дужки писати потрібно обов'язково</p>
                        <p class="sec_tit_txt_acord">Контекст</p>
                        <p> Приклади використання контексту <code>this</code> в звичайній функції та в стрілочній функції</p>
                        <ul>
                            <li class="list_style_accord"><code>function log () {<br>&nbsp console.log(this)<br>}<br> let person = {<br>&nbsp; name:'Boris',<br>&nbsp age: 29, <br>&nbsp logFunc: log<br>}<br><br> person.logFunc()</code></li>
                        </ul>
                        <p>В даному випадку в звичайній функції при використанні контексту <code>this</code> буде відображено сам об'єкт.Так як <code>function</code> формує свій власний контекст</p>
                        <ul>
                            <li class="list_style_accord"><code>let arrowLog = () => console.log(this)<br> person.arrowLog()</code></li>
                        </ul>
                        <p>В випадку стрілочної функції контекст <code>this</code> буде вказувати на глобальний об'єкт <code>window</code>. Завжди взказує на контекст який знаходиться вище</p>
                    </article>
                </div>
            </div>
            <!-- Параметри за замовчуванням -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingThree">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
                        <p class="header_name_item_stl">Праметри за замовчуванням</p>
                    </button>
                </h2>
                <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingThree" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Параметри за замовчуванням</p>
                        <p>Приклад функції з параметрами за замовчуванням:</p>
                        <ul>
                            <li class="list_style_accord">
                                <code>
                                    let somFunc = (a = 1,b = 1) => a + b<br>console.log(someFunc(40,51))
                                </code>
                                <code class="comment_code">// В Даному випадку присутня стрілочна функція, значення параметрів якої за замовчуванням 1, але якщо при викликук функції буде вказано інші параметри, для прикладу 40 та 51 то вони будуть пріорітетом для прийняття як параметр</code>
                            </li>
                            <li class="list_style_accord">
                                <code>
                                    function sumAll(...all){<br>&nbsp;
                                    console.log(all)<br>
                                    }<br>sumAll(1,2,3,4,5,6,7)
                                </code>
                                <code class="comment_code">// Для прийняття безлічі значень використовується "...all" - оператор rest. В даному випадку всі значення які будуть передані вони будуть сформовані в масив</code>
                            </li>
                            <li class="list_style_accord">
                                <code>
                                    function sumAll(...all){<code class="comment_code">// Приклад функції яка додає усі прийняті параметри, вони можуть бути збільшені або зменшені</code>
                                    <br>&nbsp;
                                    let result = 0<br>&nbsp;
                                    for (let num of all){<br>&nbsp;&nbsp;
                                    result += num<br>&nbsp;
                                    }<br>&nbsp;
                                    return result<br>
                                    }<br>
                                    let sumRes = sumAll(1,2,3,4,5,6,7)<br>console.log(sumRes)
                                </code>
                                <br>В даному випадку буде результатом загальне значення параметрів які були передані в sumAll
                            </li>
                        </ul>
                    </article>
                </div>
            </div>
            <!-- Рядки -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingFour">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFour" aria-expanded="false" aria-controls="flush-collapseFour">
                        <p class="header_name_item_stl">Рядки</p>
                    </button>
                </h2>
                <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p><code>let someText = `Привіт, мене звати ${name} мій вік ${age}`</code><code class="comment_code">// Це варіант запису являється простішим для сприймання і в <code>${..}</code> можна передавати не лише змінні а і функції, і тернарні вирази. Обов'язковою умовою є використання кавичок з нахилом<code>` `</code></code></p>
                        <p class="sec_tit_txt_acord">Нові методи роботи з рядками</p>
                        <p>Приклад методів для роботи з рядками.Для прикладу присутня змінна <code> let myName = 'Борис'</code></p>
                        <ul>
                            <li class="list_style_accord"><code>console.log(myName.startsWith('Бо'))</code> Перевірка чи рядок починається з "Бо". вертає значення true/false. Метод чутливий до регістру "Бо" "бо"</li>
                            <li class="list_style_accord"><code>console.log(myName.endsWith('ис'))</code> Перевірка чи рядок закінчується на "ис". вкртає значення true/false.</li>
                            <li class="list_style_accord"><code>console.log(myName.includes('ри'))</code> Перевірка чи є така підрядок в рядку. Вертає значення true/false. </li>
                            <li class="list_style_accord"><code>console.log(myName.repeat(3))</code> Вказуємо скільки разів повторити рядок, в даному випадку 3</li>
                            <li class="list_style_accord"><code>console.log(myName.trim())</code> Видаляє всі пробіли в змінній</li>
                            <li class="list_style_accord"><code>console.log(myName.trimStart())</code> Видалення пробілів спочатку</li>
                            <li class="list_style_accord"><code>console.log(myName.trimEnd())</code> Видалення пробілів вкінці</li>
                            <li class="list_style_accord"><code>console.log(myName.padStart(5 , 'символи якими заповнити'))</code> Задає мінімальне значення довжини та добаляє символи в початок якщо не відповідає заданій кількості</li>
                            <li class="list_style_accord"><code>console.log(myName.padEnd(5 , 'символи якими заповнити'))</code> Задає мінімальне значення довжини та добаляє символи в кінець якщо не відповідає заданій кількості</li>
                        </ul>
                    </article>
                </div>
            </div>
            <!-- Оператори rest та spread -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingFive">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFive" aria-expanded="false" aria-controls="flush-collapseFive">
                        <p class="header_name_item_stl">Оператори rest та spread</p>
                    </button>
                </h2>
                <div id="flush-collapseFive" class="accordion-collapse collapse" aria-labelledby="flush-headingFive" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Оператор Rest</p>
                        <p> Приклад використання даного оператору: </p>
                        <p><code> function someFunc(...arg) { <code class="comment_code">// '...' в даному випадку і є оператор rest. Який приймає в себе всі знічення які передаються в функцію де 'arg' це змінна яка прийме ці значення у вигляді масиву</code> <br> &nbsp; return args.reduce ((acc , i) => acc += i, 0) / args.length <br> } <br> console.log(someFunc(10,15,30,45,90))</code></p>
                        <p>В даному випадку можна в функцію передавати ще додаткові знічення, якщо перед <code>...arg</code> вказати змінні, то ця змінна буде приймати значення першого елементу який передається, а інші елементи підуть в змінну args</p>
                        <p><code> function someFunc(a, b, ...arg) { <br> &nbsp; return args.reduce ((acc , i) => acc += i, 0) / args.length <br> } <br> console.log(someFunc(10,15,30,45,90))</code> <code class="comment_code"> Де "а" = 10, "b" = 15, args = [30,45,90]</code></p>
                        <p class="sec_tit_txt_acord">Оператор Spread</p>
                        <p> Приклад використання даного оператору: </p>
                        <p><code>const arr = [1,2,6,8,12] <br> console.log(...arr)</code> <br> <code> '...' </code>в даному випадку оператор spread розгортає масив . де в консолі буде замість відображення масиву просто перелік елементів <code>1 2 6 8 12 </code> </p>
                        <p class="sec_tit_txt_acord">Деструктуризація</p>
                        <p> Даний функціонал дозволяє бистро отримувати необхідне значення, приклад використання: </p>
                        <p><code>const arr = [1,2,6,8,12] <br> const [a,b] = array <br> console.log(a,b) <br> </code> після чого ми отримали елементи 1 та 2 з масиву arr </p>
                        <p>Приклад роботи з об'єктами: </p>
                        <p><code>let person = { <br> &nbsp; age : 30,<br> &nbsp; name : 'Boris'<br> } </code></p>
                        <p><code>let {age, name} = person</code> В даному випадку отримаємо окремі змінні age та name з об'єкту person до яких можна звернутись </p>
                    </article>
                </div>
            </div>
            <!-- Об'єкти -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingSix">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSix" aria-expanded="false" aria-controls="flush-collapseSix">
                        <p class="header_name_item_stl">Об'єкти</p>
                    </button>
                </h2>
                <div id="flush-collapseSix" class="accordion-collapse collapse" aria-labelledby="flush-headingSix" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Нові методи</p>
                        <p>Для прикладу буде використовуватись об'єкт: <br> <code>let person = { <br> &nbsp; name: 'Boris', <br> &nbsp; age: 29,<br> &nbsp; country: 'Ukrain', <br> &nbsp; languages: ['UA','EN','RU'], <br>}<br></code></p>
                        <ul>
                            <li class="list_style_accord"><code>Object.keys(person)</code> <code class="comment_code"> // Отримує ключі об'єкту у вигляді масиву</code> </li>
                            <li class="list_style_accord"><code>Object.values(person)</code><code class="comment_code"> // Повертає масив значень ключів</code></li>
                            <li class="list_style_accord"><code>Object.entries(person)</code><code class="comment_code"> // Повертає масив пар [ ключ, значення ]</code></li>
                            <li class="list_style_accord"><code>Object.assign(Obj1 , Obj2)</code><code class="comment_code"> // Поєднує 2 об'єкта в 1. Якщо потрібно без зміни попередній об'єктів створити окремий , то потрібно перед першим об'єктом використати <code> { } </code> Приклад: <code>Object.assign({},Obj1, Obj2)</code></li>
                        </ul>
                        <p> Присутня змога використання динамічних ключів, приклад:</p>
                        <p><code> let city = 'Місто' <br> let person = { <br> &nbsp; name: 'Boris', <br> &nbsp; [city] : 'Київ' <br> &nbsp; age: 29,<br> &nbsp; country: 'Ukrain', <br> &nbsp; languages: ['UA','EN','RU'], <br>}<br> </code> В даному випадку додасть ключ, з назвою змінної, та з вказаним значенням. </p>
                        <p><code> let job = 'Front-end'</code> якщо назва змінної , однакова як і  назва необхідного ключа, то можливий наступний запис як ключа в об'єкті, приклад:  </p>
                        <p><code>let person = { <br> &nbsp; name: 'Boris', <br> &nbsp; job, <br> &nbsp; age: 29,<br> &nbsp; country: 'Ukrain', <br> &nbsp; languages: ['UA','EN','RU'], <br>}<br> </code></p>
                        <p>Тоді якщо переглянути об'єкт в консолі ( для прикладу ) то буде відображено ключ <code> job: 'Front-end' </code></p>
                    </article>
                </div>
            </div>
            <!-- Модулі Import/Export -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingSeven">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseSeven" aria-expanded="false" aria-controls="flush-collapseSeven">
                        <p class="header_name_item_stl">Модулі Import/Export</p>
                    </button>
                </h2>
                <div id="flush-collapseSeven" class="accordion-collapse collapse" aria-labelledby="flush-headingSeven" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Export</p>
                        <p>Export - використовується для експорту того чи іншого елементу з даного файлу</p>
                        <p>Приклад використання в коду: <code>export const color = '#fff' </code></p>
                        <p class="sec_tit_txt_acord">Import</p>
                        <p>Import - використовується для імпорту в файл раніше експортованих елементів </p>
                        <p>Приклад використання в коду: <code> import {тут вказуються назви елементів які імпортуємо} from 'тут вказується шлях до файлу з якого імпортуємо' </code></p>
                    </article>
                </div>
            </div>
            <!-- Класи -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingEight">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEight" aria-expanded="false" aria-controls="flush-collapseEight">
                        <p class="header_name_item_stl">Класи</p>
                    </button>
                </h2>
                <div id="flush-collapseEight" class="accordion-collapse collapse" aria-labelledby="flush-headingEight" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p> За допомогою ключового слова <code>class</code> можна створювати класи, приклад:</p>
                        <p><code>class Person { <br> &nbsp; тут необхідно описувати тіло класу <br> } <br> </code></p>
                        <p><code>class Person { <br> &nbsp; constructor (name) <code class="comment_code"> // name це параметр  <br> &nbsp; &nbsp; </code>this.name = name <br> &nbsp; } <br> }</code></p>
                        <p class="sec_tit_txt_acord">Наслідуванність</p>
                        <p> При формування классу , який буде наслідувати якийсь інший клас , необхідно використовувати ключове слово <code>extends</code> та вказати який клас наслідуємо, приклад:</p>
                        <p><code> class Programmer extends Person { <code class="comment_code"> // в даному прикладі клас <code>Programmer</code> наслідує клас "Person"</code> <br> &nbsp; constructor(name, job){ <br> &nbsp &nbsp super(name) <code class="comment_code"> // Ключове слово super вказує звернення на бітьківський класс , якщо звертатись до методів батьківського класу, то необхідно звертатись як до об'єкту super.greet()</code> <br> &nbsp &nbsp this.job = job <br> &nbsp } <br>}  <br> </code></p>
                        <p> Після чого буде об'єкт який буде включати і ім'я і роботу <code>let people = new Programmer ('Boris','Front-end')</code> Якщо переглянути через консоль то це буде об'єкт з ім'ям і роботою. Якщо були ще елементи в класі <code>Person</code> вони будуть також присутні в об'єкті </p>
                        <p class="sec_tit_txt_acord">get - геттер в наслідуванності</p>
                        <p>Після чого можна використовувати <code>get / set</code> get - геттер , set - сеттер </p>
                        <p>Приклад використання get :</p>
                        <p><code> class Programmer extends Person { <br> &nbsp; constructor(name, job){ <br> &nbsp &nbsp super(name) <br> &nbsp &nbsp this._job = job <br> &nbsp } <br> &nbsp; get job() { <br> &nbsp &nbsp return this._job.toUpperCase()<br> &nbsp; } <br>}  <br> </code></p>
                        <p> Таким чином відбулось звернення напряму до елементу класу job та привели його до верхнього регістру. Та можемо переглянути звернувшись напряму до нього <code>console.log(people.job)</code> </p>
                        <p class="sec_tit_txt_acord">Статичні методи</p>
                        <p>Приклад статичних методів:</p>
                        <p><code>class Util { <br> &nbsp; average(..args) { <br> &nbsp; &nbsp; return args.reduce (( acc, i) => acc += i, 0) / args.length <br> &nbsp; } <br> }</code></p>
                        <p>Так як немає змоги звернутись напряму до average необхідно зробити наступне: <br> <code>const util = new Util() <br> console.log(util.average( 1,1,2,3,5,8,13))</code> <br> Таким чином буде виконана функція average</p>
                        <p>Для того щоб уникнути даного запису, можна використати ключове слово <code>static</code></p>
                        <p><code>class Util { <br> &nbsp; static average(..args) { <br> &nbsp; &nbsp; return args.reduce (( acc, i) => acc += i, 0) / args.length <br> &nbsp; } <br> } <br> Util.average(1,1,2,3,5,8,13)</code> <br> Таким чином буде присутня змога одразу звернутись до методу average </p>

                    </article>
                </div>
            </div>
            <!-- Символи -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingNine">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <p class="header_name_item_stl">Символи (Symbol)</p>
                    </button>
                </h2>
                <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p><code>Symbol</code> - даний тип даних необхідний для задання унікальних ключуів. Тобто Symbol це певне унікальне значення</p>
                        <p>Приклад використання даного типу даних: </p>
                        <p><code>const symbol = Symbol('demo') <code class="comment_code">// Де demo являється рядком який виявляє даний символ</code> <br> let obj = { <br> &nbsp; name: 'Boris', <br>&nbsp; [symbol]: 'meta' <br> } </code></p>
                        <p>Якщо проходити по ключам за допомогою циклу<code>for in</code> то в даному випадку <code>[symbol]</code> не буде врахований в циклі</p>
                        <div class="contet_with_button">
                            <p> Більш детальніше з символами та їх видами можна ознайомитись за посиланням:</p>
                            <a class='preff_link' href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank"> Перейти до ознайомлення </a>
                        </div>
                    </article>
                </div>
            </div>
            <!-- Ітератори та генератори -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTen">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTen" aria-expanded="false" aria-controls="flush-collapseTen">
                        <p class="header_name_item_stl">ітератори / генератори</p>
                    </button>
                </h2>
                <div id="flush-collapseTen" class="accordion-collapse collapse" aria-labelledby="flush-headingTen" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Ітератори</p>
                        <p> Приклад використання ітераторів:</p>
                        <p><code>let arr = [1,2,3,4] <br> let iter = arr[Symbol.iterator]() <br> console.log(iter.next()) <br> </code> де <code>next()</code> являється методом ітератору</p>
                        <p>Для проходження по масиву використовуючи ітератор також використовують цикл <code>forof</code>. Приклад: </p>
                        <p><code>for(let i of arr){<code class="comment_code">// де "і" це ітератор</code><br> &nbsp; console.log(i)<br>}<br></code> В даному випадку буде виведено всі елементи масиву</p>
                        <p class="sec_tit_txt_acord">Генератори</p>
                        <p> Приклад використання генераторів:</p>
                        <p><code>function *gen(num = 4){ <code class="comment_code"> // Для призначення функгії генератора , достатньо використати "*" перед назвою функції</code> <br>&nbsp for (let i = 0; i менше num; i++){<br>&nbsp &nbsp yield i <code class="comment_code"> // Де "yield" ключове слово яке видає необхідне значення</code><br> &nbsp }<br> }<br> let iter = gen(3) <br> console.log(iter.next())</code></p>
                    </article>
                </div>
            </div>
            <!-- Проміси -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingEleven">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                        <p class="header_name_item_stl">Проміси</p>
                    </button>
                </h2>
                <div id="flush-collapseEleven" class="accordion-collapse collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Проміси - це зручна конструкція яка дозволяє працювати з асинхронним кодом</p>
                        <p>Приклад використання промісів: </p>
                        <p><code>const promise = new Promise((resolve,reject) => { <br> &nbsp setTimeout(() => { <br>&nbsp &nbsp console.log('Hi') <br>&nbsp ,500})<br> })</code></p>
                        <p><code>resolve , reject</code> - це являються 2 функції які можна викликита тоді коли потрібно. resolve - виконано успішно, reject - завершено з помилкою</p>
                        <p>Проміс повертає об'єкт, до якого можна використати наступні методи:</p>
                        <ul>
                            <li class="list_style_accord"><code>promise.catch</code> приклад використання: <br> <code>promise.catch(err => console.log(err))</code> Дозволяє отримати помилку </li>
                            <li class="list_style_accord"><code>promise.next</code> приклад використання: <br> <code>promise.next( data => console.log(data))</code> Тобто метод then буде викликаний тоді, коли закінчиться ассинхронний код</li>
                            <li class="list_style_accord"><code>promise.finally</code> приклад використання: <br> <code>promise.finally( data => console.log('Finally text'))</code> Викликається навіть якщо була присутня помилка</li>
                        </ul>
                        <p class="sec_tit_txt_acord">async / await</p>
                        <p>За допомогою ключового слова <code>async</code> можна позначити функцію асинхронною. Приклад:</p>
                        <p><code>async function someFuncDelay (){ <br> &nbsp; let data = await promise(500) <code class="comment_code"> // ключове слово "await" вказує до якої функції використати проміс, так як повертає значення можна присвоїти змінній </code>  <br>}</code></p>
                        <p> Для того щоб обробляти помилки не зупиняючи програму можна використати <code>try / catch</code>, приклад:</p>
                        <p><code>async function someFuncDelay (){ <br> &nbsp; try { <br> &nbsp; &nbsp; let data = await promise(500) <br> &nbsp; } <br>&nbsp; catch (e) {<br> &nbsp; &nbsp; console.log('Error', e)<br> &nbsp;  }  <br>}</code></p>
                        <p>Для роботи з групою промісів необхідно звернутись до глобального <code>Promise</code> з використанням методу <code>all</code>, приклад:</p>
                        <p><code>Promise.all([ <br> &nbsp promise(500), <br> &nbsp promise(1000), <br> &nbsp promise(1500) <br> ])</code> <br> В даному випадку буде виконано деуілька промісів та результат яких поверне у вигляді масиву, який буде також промісом. Але лише по завершенню всіх промісів</p>
                        <p>Для роботи з групою промісів необхідно звернутись до глобального <code>Promise</code> з використанням методу <code>race</code>, приклад:</p>
                        <p><code>Promise.race([ <br> &nbsp promise(500), <br> &nbsp promise(1000), <br> &nbsp promise(1500) <br> ])</code> <br> В даному випадку буде виконано деуілька промісів та результат яких поверне у вигляді масиву, який буде також промісом. Виконується після завершення найшвидчого</p>
                    </article>
                </div>
            </div>
            <!-- Структури даних map / set -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingTwelve">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                        <p class="header_name_item_stl">Структури даних map / set</p>
                    </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Map</p>
                        <p><code>Map</code> являється аналогом об'єкту, лише більш продвинутим, приклад:</p>
                        <p><code>let someMap = new Map (<br> &nbsp [ ['a', 1 ] ]<br>) <br> console.log(someMap) <code class="comment_code"> // В даному випадку буде створено об'єкт з елементом "а" який рівний 1.</code></code></p>
                        <p>Присутні методи для <code>Map</code>:</p>
                        <ul>
                            <li class="list_style_accord"><code>get("а")</code> Отримати значення певного елементу</li>
                            <li class="list_style_accord"><code>set("Б", 3)</code> Додати значення для об'єкту. Після використання повертає об'.єкт вже з цим значенням</li>
                            <li class="list_style_accord"><code>clear()</code> Повне очищення map</li>
                            <li class="list_style_accord"><code>has(12)</code> Перевірка чи наявний ключ в map</li>
                            <li class="list_style_accord"><code>delete('a')</code> Видалення ключа "а". Повертає boolean значення чи успішно чи ні видалено.</li>
                            <li class="list_style_accord"><code>size</code> Перевірка кількості елементів</li>
                            <li class="list_style_accord"><code>keys()</code> Прегляд ключів (ітератор)</li>
                            <li class="list_style_accord"><code>values()</code> Прегляд значень ключів (ітератор)</li>
                        </ul>
                        <p class="sec_tit_txt_acord">set</p>
                        <p><code>Set</code> являється аналогом масиву, але має свої особливості, він не зберігає в собі дублікати, приклад:</p>
                        <p><code> let someSet = new Set([1,1,1,1,1,3,4,5,6]) <br> console.log(someSet)</code> <br> В даному випадку буде виведено масив [1,3,4,5,6]</p>
                        <p>Методи для роботи з <code>set</code>:</p>
                        <ul>
                            <li class="list_style_accord"><code>size</code> Розмір сету </li>
                            <li class="list_style_accord"><code>add('12')</code> Додавання елементу</li>
                            <li class="list_style_accord"><code>clear()</code> Очищення сету</li>
                            <li class="list_style_accord"><code>delete(1)</code> Видалення елементу</li>
                            <li class="list_style_accord"><code>keys()</code> Перегляд елементів (ітератор)</li>
                            <li class="list_style_accord"><code>values()</code> Прегляд елементів (ітератор)</li>
                        </ul>
                    </article>
                </div>
            </div>
            <!-- Reflect -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingThirteen">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThirteen" aria-expanded="false" aria-controls="flush-collapseThirteen">
                        <p class="header_name_item_stl">Reflect</p>
                    </button>
                </h2>
                <div id="flush-collapseThirteen" class="accordion-collapse collapse" aria-labelledby="flush-headingThirteen" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>На відміну більшості глобальних об'єктів, Reflect - це конструктор. Ви не можете використовувати його з оператором new або викликати Reflect як функцію. Усі властивості та методи об'єкта Reflect є статичними (як і в об'єкта Math).</p>
                        <p>Приклад використання класу: </p>
                        <p><code>class Student {<br> &nbsp constructor(name,age){<br> &nbsp &nbsp this.name = name<br> &nbsp &nbsp this.age = age <br> &nbsp <br> &nbsp greet(){<br> &nbsp &nbsp console.log(`Hellow Mr.${this.name}, I'm ${this.age} years old`);<br> &nbsp }<br> }<br> const student = new Student('Boris',29)<br> student.greet()<br></code></p>
                        <p>Приклад використання <code>reflect</code> з класом: </p>
                        <p><code>class Student {<br> &nbsp constructor(name,age){<br> &nbsp &nbsp this.name = name<br> &nbsp &nbsp this.age = age <br> &nbsp <br> &nbsp greet(){<br> &nbsp &nbsp console.log(`Hellow Mr.${this.name}, I'm ${this.age} years old`);<br> &nbsp }<br> }<br> const student = Reflect.construct(Student, ['Boris', 29]) <code class="comment_code"> // де приймає значення Reflect.constructor(назва класу, [змінна 1,змінна 2])</code><br></code></p>
                        <p class="sec_tit_txt_acord">Методи Reflect</p>
                        <ul>
                            <li class="list_style_accord"><code>Reflect.apply(метод класу, з яким тонтекстом викликати, набір аргументів(якщо вони є в методі))</code> Дозволяє визивати методи з певним контестом та необхідними параметрами. Приклад: <br> <code> Reflect.apply(srudent.greet, {name:'Tester'}, [])</code></li>
                            <li class="list_style_accord"><code>Reflect.ownKeys(необхідний об'єкт)</code> Отримання переліку ключів об'єкту у вигляді масиву</li>
                            <li class="list_style_accord"><code>Reflect.preventExtensions(об'єкт)</code> Блокування модифікації об'єкту</li>
                            <li class="list_style_accord"><code>Reflect.isExtensible(об'єкт))</code> Перевірка чи заблокований для модифікації об'єкт</li>
                        </ul>
                        <div class="contet_with_button">
                            <p> Більш детальніше з методами <code>Reflect</code> та їх видами можна ознайомитись за посиланням:</p>
                            <a class='preff_link' href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank"> Перейти до ознайомлення </a>
                        </div>
                    </article>
                </div>
            </div>
            <!-- Proxy -->
            <div class="accordion-item fadeBlock">
                <h2 class="accordion-header" id="flush-headingForteen">
                    <button class="accordion-button collapsed btn_accord_style" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseForteen" aria-expanded="false" aria-controls="flush-collapseForteen">
                        <p class="header_name_item_stl">Proxy</p>
                    </button>
                </h2>
                <div id="flush-collapseForteen" class="accordion-collapse collapse" aria-labelledby="flush-headingForteen" data-bs-parent="#accordionFlushExample">
                    <article class="accordion_body">
                        <p class="sec_tit_txt_acord">Основи</p>
                        <p>Proxy - це клас . який дозволяє ставити пастки на любі об'єкти</p>
                        <p>Приклад Proxy: <code>const formProxy = new Proxy(form, validator)</code> - де <code>form</code> - це об'єкт який буде досліджено, <code>validator</code> - об'єкт пасток які характерні для Proxy</p>
                        <p class="sec_tit_txt_acord">Приклад використання з об'єктами</p>
                        <p>На прикладі буде створено валідатор:</p>
                        <p><code>const validator = { <br>&nbsp get (target, prop) { <br>&nbsp &nbsp return prop in target ? target[prop] : `Поля ${prop} в об'єкті відсутнє` <br>&nbsp }, <br>&nbsp set (target, prop, value){ <br>&nbsp &nbsp if (value.length > 2 ) { <br>&nbsp &nbsp &nbsp Reflect.set(target, prop, value) <code class="comment_code">// Дайний метод задає параметри</code> <br>&nbsp &nbsp } else { <br>&nbsp &nbsp &nbsp console.log('Довжина повинна бути більше двух символів, наразі ' + value.length) <br>&nbsp &nbsp }<br>&nbsp }<br> }<br> const form = { <br>&nbsp login: 'Test', <br>&nbsp pass: '12345' <br> } <br> const formProxy = new Proxy(form, validator) <br> console.log(formProxy.pass)</code></p>
                        <p>В даному випадку було створено 2 об'єкти, де <code>validator</code> - це об'єкт з правилами валідації що містить <code> get </code> i <code> set </code>, в якому медот <code> get </code> перевіряє наявність ключа в об'єкті , а <code> set </code> перевіряє його довжину, яка має бути більше 2 символів </p>
                        <p>Далі використовуємо <code>Proxy</code>: <br> <code> const formProxy = new Proxy(form, validator)</code> - де <code>form</code> - це об'єкт який буде досліджено, <code>validator</code> - об'єкт пасток які характерні для Proxy</p>
                        <p>Після чого якщо звернутись до будь якого поля досліджуваного <code>Proxy</code> об'єкту, та воно не буде відповідати валідації , будуть виведені вказані сповіщення. <code>console.log(formProxy.pass)</code></p>
                        <p class="sec_tit_txt_acord">Приклад використання з функціями</p>
                        <p><code>function log (message){ <br>&nbsp console.log('[LOG]: ', message);<br> }<br> const proxy = new Proxy(log, {<br>&nbsp apply(target, thisArg, argArray){<br>&nbsp &nbsp if (argArray.length === 1){ <br>&nbsp &nbsp &nbsp Reflect.apply(target, thisArg, argArray)<br>&nbsp &nbsp } else {<br>&nbsp &nbsp &nbsp console.log('Кількість аргументів не співпадає');<br>&nbsp &nbsp}<br>&nbsp}<br>})<br> proxy('Some message')</code></p>
                        <p>В даному випадку <code>apply</code> буде викликано якщо будемо викликати функцію <code>log</code>. <code>apply</code> приймає в себе 3 значнення: <code>target</code> - функція яку бажаємо викликати, <code>thisArg</code> - контекст, <code>argArray</code> - масив параметрів. В даному випадку якщо в <code>proxy</code> буде передано 1 параметр тоді в лог буде виведено його, якщо більше 1 , або взагалом без паарметрів, тоді буде сповіщення "Кількість аргументів не співпадає" </p>
                    </article>
                </div>
            </div>



        </div>
    </body>
</html>